# NaiveShell
首先对输入串进行parse后，调用exec族函数。
因为调用exec函数后会将可执行程序覆盖当前程序，所以不能对主进程调用exec，必须fork后用子进程调用exec
<和>的支持直接获取文件的file descriptor然后dup2到子进程的0或1file descripto
管道的支持用pipe实现，如果有n个子进程需要用n-1个管道将其串起来，所有管道均需在父进程中创建，然后为了安全可以再将其关闭
对于非后台运行的，直接在父进程中调用waitpid就行了，不许要处理太多
对于后台运行，我们不需要在父进程中调用waitpid，但是需要考虑后台程序读取标准输入，导致一系列错误，所以我直接模仿了bash之类的设计，引用进程组在我的shell里面，每一个由管道串起来的一系列命令是一个进程组，如果非后台我把它设为前台进程组，如果后台我把它设为后台进程组，这样在后台进程组在尝试读取标准输入的时候系统会将其stop。另外就是要考虑zombie进程的出现
关于信号，对于进程组的的设置需要对SIGTTOU进行处理，在父进程中需要屏蔽SIGINT等信号，对于作业控制，要用到SIGCONT，对于判断进程是否alive可以用0信号
关于后台进程组我是用链表串起来的，因为不知道后台进程什么时候执行完，所以在执行jobs是再向每个进程组发送0信号判断是否还存在，如果不存在则删除
内置指令不能用exec实现，需要自己实现
指令补全，用了GNU READLINE库，另外他的自动补全只是不全文件名，如果要不全指令之类的需要自己去/bin之类的路径把所有指令读出来放在自定义补全函数中，顺便还用了history头文件，用于查询历史和在文件中永久存储
至于别名就比较简单了，用c语言字符串函数处理
